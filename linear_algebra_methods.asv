A = [3 -2 1 ; 1 -3 2 ; -1 2 4]
b = [4, 50, 8];

x = solve_with_gauss(A, b);
A*x

x = solve_with_gauss_seidel(A, b, 0.05);
A*x

syms x
f(x) = str2sym('x + 3')

solve_with_bisection(f, 10, -5, 0.05)

function x = solve_with_bisection(f, x_l, x_u, threshold)  
    if f(x_l)*f(x_u) > 0
        disp("Los valores iniciales deben tener signos distintos")
        x = false
        return
    end
    
    % Define a vector with x_r(i) being the old approximation
    x_r = zeros(2, 1)
    
    error = 1;
    
    while error > threshold
        x_r(2) = (x_l + x_u)/2;
        product = f(x_l)*f(x_r);
        
        
        if product < 0
            x_u = x_r;
        elseif product > 0
            x_l = x_r;
        else
            x = x_r;
            return
        end
        
        error = abs((x_r(2) - x_r(1))/x_r(2));
    end
    
    x = x_r;
end

function sol = solve_with_gauss_seidel(A, b, threshold)
    [n, ~] = size(A);
    
    if ~check_diagonally_dominant(A)
        disp("No se puede resolver con este metodo porque la matriz no es diagonalmente dominante")
        sol = false
        return
    end
    
    x = zeros(n, 1);
    errors = zeros(n, 1);
    
    for i = 1:n
        errors(i) = 100;
    end
    
    while sum(errors < threshold) ~= n
        for i = 1:n
            aux = x;
            x_last = aux(i);
            aux(i) = 0;
            
            % Update x_i value 
            x(i) = (b(i) - dot(aux, A(i, 1:n)))/A(i, i);
           
            % Update errors_i value
            errors(i) = abs((x(i) - x_last)/x(i))*100;
        end
        
    end
    
    sol = x;
end

function x = check_diagonally_dominant(A)
    [n, ~] = size(A);
    
    for row = 1:n
       if abs(A(row, row)) >= sum_abs(A(row, :)) - abs(A(row, row))
           continue
       else
           x = false;
           return
       end
    end
    
    x = true;
end

function x = sum_abs(v)
    s = 0
    for i = 1:size(v)
        s = s + abs(v(i));
    end
    
    x = s;
end


function x = solve_with_cramer(A, b)
    [n, ~] = size(A);
    det_A = determinant(A);
    
    if det_A == false || det_A == 0
        x = false;
        return
    end
    
    x = zeros(n, 1);
    
    for i = 1:n
       aux = A;
       aux(:, i) = b;
       
       x(i) = determinant(aux)/det_A;
    end
end

function x = solve_with_LU(A, b)
    n = length(b);
    x = zeros(n, 1);
    y = zeros(n, 1);

    for i = 1:1:n
        for j = 1:1:(i - 1)
            a = A(i,j);
            for k = 1:1:(j - 1)
                a = a - A(i,k)*A(k,j);
            end
            A(i,j) = a/A(j,j);
        end
        for j = i:1:n
            a = A(i,j);
            for k = 1:1:(i - 1)
                a = a - A(i,k)*A(k,j);
            end
            A(i,j) = a;
        end
    end

    for i = 1:1:n
        a = 0;
        for k = 1:1:i
            a = a + A(i,k)*y(k);
        end
        y(i) = b(i) - a;
    end

    for i = n:(-1):1
        a = 0;
        for k = (i + 1):1:n
            a = a + A(i,k)*x(k);
        end
        x(i) = (y(i) - a)/A(i, i);
    end    
end

function x = solve_with_gauss_jordan(A, b)
    b = b';
    
    if determinant(A) == false
        x = false;
        return
    end
    
    aug = augment(A, b);
    U = make_upper(aug);
    
    ident_aug = make_ident(U);
    ident_aug = reduce_ref(ident_aug);
    
    x = ident_aug(:, end);
end

function x = solve_with_gauss(A, b)
    b = b';
    
    if determinant(A) == false
        x = false;
        return
    end
    
    aug = augment(A, b);
    A = make_upper(aug);
    
    x = solve_ref(A);
end

function x = solve_with_inverse(A, b)
    if determinant(A) == false
        x = false;
        return
    end
    
    [n, ~] = size(A);
    
    aug = augment(A, eye(n));
    U = make_upper(aug);
    ident_aug = make_ident(U);
    
    ident_aug = reduce_ref(ident_aug);
    inverse = ident_aug(:, n+1:n+n);
    
    x = inverse*b';
end

function aug = augment(A, b)
   A = [A, b];
 
   aug = A;
end

function sol = make_ident(A)
    % Esta función toma como input una matriz aumentada con el lado
    % izquierdo en forma superior, y lo convierte a la identidad
    [n, ~] = size(A);
    
    for row_reverse = n:-1:2
       for row = 1:row_reverse - 1
           A(row, :) = A(row, :) - (A(row, row_reverse)/A(row_reverse, row_reverse))*A(row_reverse, :);
       end
    end
    
    sol = A;
end

function sol = reduce_ref(A)
    [n, ~] = size(A);
    
   for row = 1:n       
       A(row, :) = A(row, :)/A(row, row);
   end
    
    sol = A;
end

function det = determinant(A)
    % Calcular la determinante de una matriz A
    [n, m] = size(A);
    
    if n ~= m
        det = false;
        return
    end
    
    A = make_upper(A);

    
    if A == false
        disp('La matriz no tiene solución única porque su determinante es 0');
        det = false;
        return
    end
    
    determinant_value = 1;
    
    for row = 1:n
        for col = 1:m
            if row == col
                determinant_value = determinant_value*A(row, col);
            end
        end
    end
    
    det = determinant_value;
    return
end

function sol = make_upper(A)
    % Convierte a forma fila-escalon una matrix
    % m_limit es la ultima columna antes de que comience la parte aumentada
   [n, ~] = size(A);
   
   % Asegurar que la fila 1 tiene valor diferente de 0
   for row = 1:n
       for col = 1:n
           if row == col
               
              if A == 0
                 sol = false;
                 return
              end
              
              A = make_pivot_column(A, row, col);
           end
       end
   end
   
   sol = A;
end

function sol = solve_ref(A)
    [n, m] = size(A);
    
    if n ~= m-1
        sol = false;
        return
    end
    
    b = A(:, m);
    
    x = zeros(n, 1);
    x(n) = b(n)/(A(n, n));
    
    for i = n-1:-1:1
        x(i) = (b(i) - dot(A(i, i:n), x(i:n)))/(A(i, i));
    end
    
    sol = x;
end

function x = make_pivot_column(A, i, j)
    A = ensure_pivot(A, i, j);
    
    if A == false
        x = false;
        return
    end
    
    [n, ~] = size(A);
        
    for row = i+1:n
       A(row, :) = A(row, :) - (A(row, j)/A(i, j))*A(i, :);
    end
    
    x = A;
    
end

function x = ensure_pivot(A, i, j)    
    if A(i, j) ~= 0
        x = A;
    else
        [n, ~] = size(A);
        
        for row = i+1:n
            if A(row, j) ~= 0
                x = exchange_rows(A, j, row);
                return
            end
        end
        
        x = false;
    end
end

function x = exchange_rows(A, row1, row2)
    temp = A(row2, :);
    A(row2, :) = A(row1, :);
    A(row1, :) = temp;
    
    x = A;
end

